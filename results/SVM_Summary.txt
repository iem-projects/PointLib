Map[Int, Map[Int,          Int]]

    i-class  i-class (co)  freq

all-intervals, as interval classes (0...6)

d.h. es gibt 7 + 6 + 5 + 4 + 3 + 2 + 1 = 28 combinations von interval-klassen

  def kreuzVec(map: Map[Int, Map[Int, Int]]): Vec[Vec[Int]] =
    Vec.tabulate(7)(x => Vec.tabulate(x + 1)(y => map(x)(y)))

also ist die reihenfolge (mit flatten):

Vector.tabulate(7)(x => Vector.tabulate(x + 1)(y => x -> y)).flatten.zipWithIndex.map { case (tup, i) => f"$i%2d: ${tup.swap}" } .foreach(println)

val tups = Vector.tabulate(7)(x => Vector.tabulate(x + 1)(y => x -> y)).flatten.map(_.swap)

def lookup(in: Seq[Int]) = in.map(tups.apply).sorted

 0: (0,0)
 1: (0,1)
 2: (1,1)
 3: (0,2)
 4: (1,2)
 5: (2,2)
 6: (0,3)
 7: (1,3)
 8: (2,3)
 9: (3,3)
10: (0,4)
11: (1,4)
12: (2,4)
13: (3,4)
14: (4,4)
15: (0,5)
16: (1,5)
17: (2,5)
18: (3,5)
19: (4,5)
20: (5,5)
21: (0,6)
22: (1,6)
23: (2,6)
24: (3,6)
25: (4,6)
26: (5,6)
27: (6,6)

::::::::::::::::::::::::::::::::

def area(r: Double) = r*r*math.Pi
def radius(a: Double) = math.sqrt(a/math.Pi)

def x = (n: Double) => radius(n) * 2 // 4


// def c(in: Double) = in.linlin(55.172413, 76.47059, 0, 1).squared.linlin(0, 1, 20, 60)
def c1(in: Double) = in.linlin(55.172413, 76.47059, 0, 1).squared.linlin(0, 1, 204, 102)

x(55.172413)
c1(76.47059)

